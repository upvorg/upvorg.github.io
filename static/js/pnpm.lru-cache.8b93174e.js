"use strict";(self.webpackChunk_web_index=self.webpackChunk_web_index||[]).push([[648],{8288:(t,e,i)=>{i.d(e,{q:()=>f});const s="object"===typeof performance&&performance&&"function"===typeof performance.now?performance:Date,h=new Set,o="object"===typeof process&&process?process:{},n=(t,e,i,s)=>{"function"===typeof o.emitWarning?o.emitWarning(t,e,i,s):console.error(`[${i}] ${e}: ${t}`)};let a=globalThis.AbortController,r=globalThis.AbortSignal;if("undefined"===typeof a){r=class{onabort;_onabort=[];reason;aborted=!1;addEventListener(t,e){this._onabort.push(e)}},a=class{constructor(){e()}signal=new r;abort(t){if(!this.signal.aborted){this.signal.reason=t,this.signal.aborted=!0;for(const e of this.signal._onabort)e(t);this.signal.onabort?.(t)}}};let t="1"!==o.env?.LRU_CACHE_IGNORE_AC_WARNING;const e=()=>{t&&(t=!1,n("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.","NO_ABORT_CONTROLLER","ENOTSUP",e))}}Symbol("type");const l=t=>t&&t===Math.floor(t)&&t>0&&isFinite(t),c=t=>l(t)?t<=Math.pow(2,8)?Uint8Array:t<=Math.pow(2,16)?Uint16Array:t<=Math.pow(2,32)?Uint32Array:t<=Number.MAX_SAFE_INTEGER?d:null:null;class d extends Array{constructor(t){super(t),this.fill(0)}}class u{heap;length;static#t=!1;static create(t){const e=c(t);if(!e)return[];u.#t=!0;const i=new u(t,e);return u.#t=!1,i}constructor(t,e){if(!u.#t)throw new TypeError("instantiate Stack using Stack.create(n)");this.heap=new e(t),this.length=0}push(t){this.heap[this.length++]=t}pop(){return this.heap[--this.length]}}class f{#e;#i;#s;#h;#o;ttl;ttlResolution;ttlAutopurge;updateAgeOnGet;updateAgeOnHas;allowStale;noDisposeOnSet;noUpdateTTL;maxEntrySize;sizeCalculation;noDeleteOnFetchRejection;noDeleteOnStaleGet;allowStaleOnFetchAbort;allowStaleOnFetchRejection;ignoreFetchAbort;#n;#a;#r;#l;#c;#d;#u;#f;#p;#g;#v;#S;#m;#z;#y;#w;#L;static unsafeExposeInternals(t){return{starts:t.#m,ttls:t.#z,sizes:t.#S,keyMap:t.#r,keyList:t.#l,valList:t.#c,next:t.#d,prev:t.#u,get head(){return t.#f},get tail(){return t.#p},free:t.#g,isBackgroundFetch:e=>t.#F(e),backgroundFetch:(e,i,s,h)=>t.#_(e,i,s,h),moveToTail:e=>t.#A(e),indexes:e=>t.#x(e),rindexes:e=>t.#k(e),isStale:e=>t.#T(e)}}get max(){return this.#e}get maxSize(){return this.#i}get calculatedSize(){return this.#a}get size(){return this.#n}get fetchMethod(){return this.#o}get dispose(){return this.#s}get disposeAfter(){return this.#h}constructor(t){const{max:e=0,ttl:i,ttlResolution:s=1,ttlAutopurge:o,updateAgeOnGet:a,updateAgeOnHas:r,allowStale:d,dispose:p,disposeAfter:g,noDisposeOnSet:v,noUpdateTTL:S,maxSize:m=0,maxEntrySize:z=0,sizeCalculation:y,fetchMethod:w,noDeleteOnFetchRejection:L,noDeleteOnStaleGet:F,allowStaleOnFetchRejection:_,allowStaleOnFetchAbort:A,ignoreFetchAbort:x}=t;if(0!==e&&!l(e))throw new TypeError("max option must be a nonnegative integer");const k=e?c(e):Array;if(!k)throw new Error("invalid max value: "+e);if(this.#e=e,this.#i=m,this.maxEntrySize=z||this.#i,this.sizeCalculation=y,this.sizeCalculation){if(!this.#i&&!this.maxEntrySize)throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");if("function"!==typeof this.sizeCalculation)throw new TypeError("sizeCalculation set to non-function")}if(void 0!==w&&"function"!==typeof w)throw new TypeError("fetchMethod must be a function if specified");if(this.#o=w,this.#w=!!w,this.#r=new Map,this.#l=new Array(e).fill(void 0),this.#c=new Array(e).fill(void 0),this.#d=new k(e),this.#u=new k(e),this.#f=0,this.#p=0,this.#g=u.create(e),this.#n=0,this.#a=0,"function"===typeof p&&(this.#s=p),"function"===typeof g?(this.#h=g,this.#v=[]):(this.#h=void 0,this.#v=void 0),this.#y=!!this.#s,this.#L=!!this.#h,this.noDisposeOnSet=!!v,this.noUpdateTTL=!!S,this.noDeleteOnFetchRejection=!!L,this.allowStaleOnFetchRejection=!!_,this.allowStaleOnFetchAbort=!!A,this.ignoreFetchAbort=!!x,0!==this.maxEntrySize){if(0!==this.#i&&!l(this.#i))throw new TypeError("maxSize must be a positive integer if specified");if(!l(this.maxEntrySize))throw new TypeError("maxEntrySize must be a positive integer if specified");this.#b()}if(this.allowStale=!!d,this.noDeleteOnStaleGet=!!F,this.updateAgeOnGet=!!a,this.updateAgeOnHas=!!r,this.ttlResolution=l(s)||0===s?s:1,this.ttlAutopurge=!!o,this.ttl=i||0,this.ttl){if(!l(this.ttl))throw new TypeError("ttl must be a positive integer if specified");this.#O()}if(0===this.#e&&0===this.ttl&&0===this.#i)throw new TypeError("At least one of max, maxSize, or ttl is required");if(!this.ttlAutopurge&&!this.#e&&!this.#i){const t="LRU_CACHE_UNBOUNDED";if((t=>!h.has(t))(t)){h.add(t);n("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.","UnboundedCacheWarning",t,f)}}}getRemainingTTL(t){return this.#r.has(t)?1/0:0}#O(){const t=new d(this.#e),e=new d(this.#e);this.#z=t,this.#m=e,this.#D=(i,h,o=s.now())=>{if(e[i]=0!==h?o:0,t[i]=h,0!==h&&this.ttlAutopurge){const t=setTimeout((()=>{this.#T(i)&&this.delete(this.#l[i])}),h+1);t.unref&&t.unref()}},this.#E=i=>{e[i]=0!==t[i]?s.now():0},this.#C=(s,o)=>{if(t[o]){const n=t[o],a=e[o];if(!n||!a)return;s.ttl=n,s.start=a,s.now=i||h();const r=s.now-a;s.remainingTTL=n-r}};let i=0;const h=()=>{const t=s.now();if(this.ttlResolution>0){i=t;const e=setTimeout((()=>i=0),this.ttlResolution);e.unref&&e.unref()}return t};this.getRemainingTTL=s=>{const o=this.#r.get(s);if(void 0===o)return 0;const n=t[o],a=e[o];if(!n||!a)return 1/0;return n-((i||h())-a)},this.#T=s=>{const o=e[s],n=t[s];return!!n&&!!o&&(i||h())-o>n}}#E=()=>{};#C=()=>{};#D=()=>{};#T=()=>!1;#b(){const t=new d(this.#e);this.#a=0,this.#S=t,this.#M=e=>{this.#a-=t[e],t[e]=0},this.#R=(t,e,i,s)=>{if(this.#F(e))return 0;if(!l(i)){if(!s)throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");if("function"!==typeof s)throw new TypeError("sizeCalculation must be a function");if(i=s(e,t),!l(i))throw new TypeError("sizeCalculation return invalid (expect positive integer)")}return i},this.#W=(e,i,s)=>{if(t[e]=i,this.#i){const i=this.#i-t[e];for(;this.#a>i;)this.#I(!0)}this.#a+=t[e],s&&(s.entrySize=i,s.totalCalculatedSize=this.#a)}}#M=t=>{};#W=(t,e,i)=>{};#R=(t,e,i,s)=>{if(i||s)throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");return 0};*#x({allowStale:t=this.allowStale}={}){if(this.#n)for(let e=this.#p;this.#B(e)&&(!t&&this.#T(e)||(yield e),e!==this.#f);)e=this.#u[e]}*#k({allowStale:t=this.allowStale}={}){if(this.#n)for(let e=this.#f;this.#B(e)&&(!t&&this.#T(e)||(yield e),e!==this.#p);)e=this.#d[e]}#B(t){return void 0!==t&&this.#r.get(this.#l[t])===t}*entries(){for(const t of this.#x())void 0===this.#c[t]||void 0===this.#l[t]||this.#F(this.#c[t])||(yield[this.#l[t],this.#c[t]])}*rentries(){for(const t of this.#k())void 0===this.#c[t]||void 0===this.#l[t]||this.#F(this.#c[t])||(yield[this.#l[t],this.#c[t]])}*keys(){for(const t of this.#x()){const e=this.#l[t];void 0===e||this.#F(this.#c[t])||(yield e)}}*rkeys(){for(const t of this.#k()){const e=this.#l[t];void 0===e||this.#F(this.#c[t])||(yield e)}}*values(){for(const t of this.#x()){void 0===this.#c[t]||this.#F(this.#c[t])||(yield this.#c[t])}}*rvalues(){for(const t of this.#k()){void 0===this.#c[t]||this.#F(this.#c[t])||(yield this.#c[t])}}[Symbol.iterator](){return this.entries()}[Symbol.toStringTag]="LRUCache";find(t,e={}){for(const i of this.#x()){const s=this.#c[i],h=this.#F(s)?s.__staleWhileFetching:s;if(void 0!==h&&t(h,this.#l[i],this))return this.get(this.#l[i],e)}}forEach(t,e=this){for(const i of this.#x()){const s=this.#c[i],h=this.#F(s)?s.__staleWhileFetching:s;void 0!==h&&t.call(e,h,this.#l[i],this)}}rforEach(t,e=this){for(const i of this.#k()){const s=this.#c[i],h=this.#F(s)?s.__staleWhileFetching:s;void 0!==h&&t.call(e,h,this.#l[i],this)}}purgeStale(){let t=!1;for(const e of this.#k({allowStale:!0}))this.#T(e)&&(this.delete(this.#l[e]),t=!0);return t}info(t){const e=this.#r.get(t);if(void 0===e)return;const i=this.#c[e],h=this.#F(i)?i.__staleWhileFetching:i;if(void 0===h)return;const o={value:h};if(this.#z&&this.#m){const t=this.#z[e],i=this.#m[e];if(t&&i){const e=t-(s.now()-i);o.ttl=e,o.start=Date.now()}}return this.#S&&(o.size=this.#S[e]),o}dump(){const t=[];for(const e of this.#x({allowStale:!0})){const i=this.#l[e],h=this.#c[e],o=this.#F(h)?h.__staleWhileFetching:h;if(void 0===o||void 0===i)continue;const n={value:o};if(this.#z&&this.#m){n.ttl=this.#z[e];const t=s.now()-this.#m[e];n.start=Math.floor(Date.now()-t)}this.#S&&(n.size=this.#S[e]),t.unshift([i,n])}return t}load(t){this.clear();for(const[e,i]of t){if(i.start){const t=Date.now()-i.start;i.start=s.now()-t}this.set(e,i.value,i)}}set(t,e,i={}){if(void 0===e)return this.delete(t),this;const{ttl:s=this.ttl,start:h,noDisposeOnSet:o=this.noDisposeOnSet,sizeCalculation:n=this.sizeCalculation,status:a}=i;let{noUpdateTTL:r=this.noUpdateTTL}=i;const l=this.#R(t,e,i.size||0,n);if(this.maxEntrySize&&l>this.maxEntrySize)return a&&(a.set="miss",a.maxEntrySizeExceeded=!0),this.delete(t),this;let c=0===this.#n?void 0:this.#r.get(t);if(void 0===c)c=0===this.#n?this.#p:0!==this.#g.length?this.#g.pop():this.#n===this.#e?this.#I(!1):this.#n,this.#l[c]=t,this.#c[c]=e,this.#r.set(t,c),this.#d[this.#p]=c,this.#u[c]=this.#p,this.#p=c,this.#n++,this.#W(c,l,a),a&&(a.set="add"),r=!1;else{this.#A(c);const i=this.#c[c];if(e!==i){if(this.#w&&this.#F(i)){i.__abortController.abort(new Error("replaced"));const{__staleWhileFetching:e}=i;void 0===e||o||(this.#y&&this.#s?.(e,t,"set"),this.#L&&this.#v?.push([e,t,"set"]))}else o||(this.#y&&this.#s?.(i,t,"set"),this.#L&&this.#v?.push([i,t,"set"]));if(this.#M(c),this.#W(c,l,a),this.#c[c]=e,a){a.set="replace";const t=i&&this.#F(i)?i.__staleWhileFetching:i;void 0!==t&&(a.oldValue=t)}}else a&&(a.set="update")}if(0===s||this.#z||this.#O(),this.#z&&(r||this.#D(c,s,h),a&&this.#C(a,c)),!o&&this.#L&&this.#v){const t=this.#v;let e;for(;e=t?.shift();)this.#h?.(...e)}return this}pop(){try{for(;this.#n;){const t=this.#c[this.#f];if(this.#I(!0),this.#F(t)){if(t.__staleWhileFetching)return t.__staleWhileFetching}else if(void 0!==t)return t}}finally{if(this.#L&&this.#v){const t=this.#v;let e;for(;e=t?.shift();)this.#h?.(...e)}}}#I(t){const e=this.#f,i=this.#l[e],s=this.#c[e];return this.#w&&this.#F(s)?s.__abortController.abort(new Error("evicted")):(this.#y||this.#L)&&(this.#y&&this.#s?.(s,i,"evict"),this.#L&&this.#v?.push([s,i,"evict"])),this.#M(e),t&&(this.#l[e]=void 0,this.#c[e]=void 0,this.#g.push(e)),1===this.#n?(this.#f=this.#p=0,this.#g.length=0):this.#f=this.#d[e],this.#r.delete(i),this.#n--,e}has(t,e={}){const{updateAgeOnHas:i=this.updateAgeOnHas,status:s}=e,h=this.#r.get(t);if(void 0!==h){const t=this.#c[h];if(this.#F(t)&&void 0===t.__staleWhileFetching)return!1;if(!this.#T(h))return i&&this.#E(h),s&&(s.has="hit",this.#C(s,h)),!0;s&&(s.has="stale",this.#C(s,h))}else s&&(s.has="miss");return!1}peek(t,e={}){const{allowStale:i=this.allowStale}=e,s=this.#r.get(t);if(void 0===s||!i&&this.#T(s))return;const h=this.#c[s];return this.#F(h)?h.__staleWhileFetching:h}#_(t,e,i,s){const h=void 0===e?void 0:this.#c[e];if(this.#F(h))return h;const o=new a,{signal:n}=i;n?.addEventListener("abort",(()=>o.abort(n.reason)),{signal:o.signal});const r={signal:o.signal,options:i,context:s},l=(s,h=!1)=>{const{aborted:n}=o.signal,a=i.ignoreFetchAbort&&void 0!==s;if(i.status&&(n&&!h?(i.status.fetchAborted=!0,i.status.fetchError=o.signal.reason,a&&(i.status.fetchAbortIgnored=!0)):i.status.fetchResolved=!0),n&&!a&&!h)return c(o.signal.reason);const l=d;return this.#c[e]===d&&(void 0===s?l.__staleWhileFetching?this.#c[e]=l.__staleWhileFetching:this.delete(t):(i.status&&(i.status.fetchUpdated=!0),this.set(t,s,r.options))),s},c=s=>{const{aborted:h}=o.signal,n=h&&i.allowStaleOnFetchAbort,a=n||i.allowStaleOnFetchRejection,r=a||i.noDeleteOnFetchRejection,l=d;if(this.#c[e]===d){!r||void 0===l.__staleWhileFetching?this.delete(t):n||(this.#c[e]=l.__staleWhileFetching)}if(a)return i.status&&void 0!==l.__staleWhileFetching&&(i.status.returnedStale=!0),l.__staleWhileFetching;if(l.__returned===l)throw s};i.status&&(i.status.fetchDispatched=!0);const d=new Promise(((e,s)=>{const n=this.#o?.(t,h,r);n&&n instanceof Promise&&n.then((t=>e(void 0===t?void 0:t)),s),o.signal.addEventListener("abort",(()=>{i.ignoreFetchAbort&&!i.allowStaleOnFetchAbort||(e(void 0),i.allowStaleOnFetchAbort&&(e=t=>l(t,!0)))}))})).then(l,(t=>(i.status&&(i.status.fetchRejected=!0,i.status.fetchError=t),c(t)))),u=Object.assign(d,{__abortController:o,__staleWhileFetching:h,__returned:void 0});return void 0===e?(this.set(t,u,{...r.options,status:void 0}),e=this.#r.get(t)):this.#c[e]=u,u}#F(t){if(!this.#w)return!1;const e=t;return!!e&&e instanceof Promise&&e.hasOwnProperty("__staleWhileFetching")&&e.__abortController instanceof a}async fetch(t,e={}){const{allowStale:i=this.allowStale,updateAgeOnGet:s=this.updateAgeOnGet,noDeleteOnStaleGet:h=this.noDeleteOnStaleGet,ttl:o=this.ttl,noDisposeOnSet:n=this.noDisposeOnSet,size:a=0,sizeCalculation:r=this.sizeCalculation,noUpdateTTL:l=this.noUpdateTTL,noDeleteOnFetchRejection:c=this.noDeleteOnFetchRejection,allowStaleOnFetchRejection:d=this.allowStaleOnFetchRejection,ignoreFetchAbort:u=this.ignoreFetchAbort,allowStaleOnFetchAbort:f=this.allowStaleOnFetchAbort,context:p,forceRefresh:g=!1,status:v,signal:S}=e;if(!this.#w)return v&&(v.fetch="get"),this.get(t,{allowStale:i,updateAgeOnGet:s,noDeleteOnStaleGet:h,status:v});const m={allowStale:i,updateAgeOnGet:s,noDeleteOnStaleGet:h,ttl:o,noDisposeOnSet:n,size:a,sizeCalculation:r,noUpdateTTL:l,noDeleteOnFetchRejection:c,allowStaleOnFetchRejection:d,allowStaleOnFetchAbort:f,ignoreFetchAbort:u,status:v,signal:S};let z=this.#r.get(t);if(void 0===z){v&&(v.fetch="miss");const e=this.#_(t,z,m,p);return e.__returned=e}{const e=this.#c[z];if(this.#F(e)){const t=i&&void 0!==e.__staleWhileFetching;return v&&(v.fetch="inflight",t&&(v.returnedStale=!0)),t?e.__staleWhileFetching:e.__returned=e}const h=this.#T(z);if(!g&&!h)return v&&(v.fetch="hit"),this.#A(z),s&&this.#E(z),v&&this.#C(v,z),e;const o=this.#_(t,z,m,p),n=void 0!==o.__staleWhileFetching&&i;return v&&(v.fetch=h?"stale":"refresh",n&&h&&(v.returnedStale=!0)),n?o.__staleWhileFetching:o.__returned=o}}get(t,e={}){const{allowStale:i=this.allowStale,updateAgeOnGet:s=this.updateAgeOnGet,noDeleteOnStaleGet:h=this.noDeleteOnStaleGet,status:o}=e,n=this.#r.get(t);if(void 0!==n){const e=this.#c[n],a=this.#F(e);return o&&this.#C(o,n),this.#T(n)?(o&&(o.get="stale"),a?(o&&i&&void 0!==e.__staleWhileFetching&&(o.returnedStale=!0),i?e.__staleWhileFetching:void 0):(h||this.delete(t),o&&i&&(o.returnedStale=!0),i?e:void 0)):(o&&(o.get="hit"),a?e.__staleWhileFetching:(this.#A(n),s&&this.#E(n),e))}o&&(o.get="miss")}#G(t,e){this.#u[e]=t,this.#d[t]=e}#A(t){t!==this.#p&&(t===this.#f?this.#f=this.#d[t]:this.#G(this.#u[t],this.#d[t]),this.#G(this.#p,t),this.#p=t)}delete(t){let e=!1;if(0!==this.#n){const i=this.#r.get(t);if(void 0!==i)if(e=!0,1===this.#n)this.clear();else{this.#M(i);const e=this.#c[i];if(this.#F(e)?e.__abortController.abort(new Error("deleted")):(this.#y||this.#L)&&(this.#y&&this.#s?.(e,t,"delete"),this.#L&&this.#v?.push([e,t,"delete"])),this.#r.delete(t),this.#l[i]=void 0,this.#c[i]=void 0,i===this.#p)this.#p=this.#u[i];else if(i===this.#f)this.#f=this.#d[i];else{const t=this.#u[i];this.#d[t]=this.#d[i];const e=this.#d[i];this.#u[e]=this.#u[i]}this.#n--,this.#g.push(i)}}if(this.#L&&this.#v?.length){const t=this.#v;let e;for(;e=t?.shift();)this.#h?.(...e)}return e}clear(){for(const t of this.#k({allowStale:!0})){const e=this.#c[t];if(this.#F(e))e.__abortController.abort(new Error("deleted"));else{const i=this.#l[t];this.#y&&this.#s?.(e,i,"delete"),this.#L&&this.#v?.push([e,i,"delete"])}}if(this.#r.clear(),this.#c.fill(void 0),this.#l.fill(void 0),this.#z&&this.#m&&(this.#z.fill(0),this.#m.fill(0)),this.#S&&this.#S.fill(0),this.#f=0,this.#p=0,this.#g.length=0,this.#a=0,this.#n=0,this.#L&&this.#v){const t=this.#v;let e;for(;e=t?.shift();)this.#h?.(...e)}}}}}]);